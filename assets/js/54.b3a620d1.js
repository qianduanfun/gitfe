(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{453:function(e,t,n){"use strict";n.r(t);var s=n(48),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[n("img",{attrs:{src:"http://i.simbel.cn/note/20200219175908.png",alt:"20200219175908"}})]),e._v(" "),n("h1",{attrs:{id:"react-hooks-入门-useeffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-入门-useeffect"}},[e._v("#")]),e._v(" React Hooks 入门-useEffect")]),e._v(" "),n("h2",{attrs:{id:"useeffect介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect介绍"}},[e._v("#")]),e._v(" useEffect介绍")]),e._v(" "),n("p",[e._v("useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。")]),e._v(" "),n("p",[e._v("React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect")]),e._v(" "),n("p",[e._v("以前，放在componentDidMount里面的代码，现在可以放在useEffect()。")]),e._v(" "),n("p",[e._v("使用示例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect } from 'react'\n\nexport default function Demo01(){\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    document.title = `clicked ${count} times`\n  })\n\n  return (<div>\n    <button onClick={() => setCount(count + 1)}>点击</button>\n  </div>)\n}\n")])])]),n("h2",{attrs:{id:"如何让useeffect只执行一次"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何让useeffect只执行一次"}},[e._v("#")]),e._v(" 如何让useEffect只执行一次")]),e._v(" "),n("blockquote",[n("p",[e._v("在function组件中，每当DOM完成一次渲染，都会有对应的副作用执行，useEffect用于提供自定义的执行内容，它的第一个参数（作为函数传入）就是自定义的执行内容。为了避免反复执行，传入第二个参数（由监听值组成的数组）作为比较(浅比较)变化的依赖，比较之后值都保持不变时，副作用逻辑就不再执行。")])]),e._v(" "),n("p",[e._v("如果希望useEffect只执行一次，可以给带二个参数传入一个空数组，即没有传入比较变化的变量，则比较结果永远都保持不变，那么副作用逻辑就只能执行一次。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect } from 'react'\n\nexport default function Demo01(){\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    console.log('执行useEffect') // 只会打印一次\n  }, [])\n\n  return (<div>\n    <button onClick={() => setCount(count + 1)}>点击</button>\n  </div>)\n}\n")])])]),n("h2",{attrs:{id:"useeffect-依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect-依赖"}},[e._v("#")]),e._v(" useEffect 依赖")]),e._v(" "),n("p",[e._v("也可以让组件根据参数变化，执行useEffect，如下示例，Person组件根据传入的userid获取用户信息，userid不变的话不会重复执行")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React, { useState, useEffect } from "react";\n\nfunction Person({ userid }) {\n  const [person, setPerson] = useState();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    console.log("exec useEffect");\n    setLoading(true);\n    fetch(`https://swapi.co/api/people/${userid}`)\n      .then(res => res.json())\n      .then(data => {\n        setPerson(data);\n        setLoading(false);\n      });\n  }, [userid]);\n\n  return (\n    <div>\n      用户信息：\n      <p>{loading ? "Loading..." : JSON.stringify(person)}</p>\n    </div>\n  );\n}\n\nexport default function Demo03() {\n  const [userid, setuUserid] = useState(1);\n  return (\n    <>\n      <button onClick={() => setuUserid(1)}>用户1</button>\n      <button onClick={() => setuUserid(2)}>用户2</button>\n      <Person userid={userid} />\n    </>\n  );\n}\n\n')])])]),n("blockquote",[n("ul",[n("li",[e._v("当依赖值为 object 时,他的值引用发生变化就会触发 effect 的更新，但是如果只是对象里某个值变化而引用不变化,effect 依旧不会触发")]),e._v(" "),n("li",[e._v("如果初始值为 function, 而将其改为数字等,会触发 effect，function 也是一个对象,当我们添加一个值在上面时,他的 effect 也不会触发，引用为一个新函数时,他每次都会触发;")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect } from 'react'\n\nexport default function Demo02(){\n  let [data, setData] = useState({a: 123})\n  useEffect(() => {\n    console.log('执行useEffect')\n  }, [data])\n  const handleData = () => {\n    data.a = Math.random() // 不会触发effect\n    // setData({ a: 123 }) // 每次都会触发effect，引用地址发生了变化\n  }\n\n  return (<div>\n    <button onClick={handleData}>点击</button>\n  </div>)\n}\n")])])]),n("h2",{attrs:{id:"如何清除useeffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何清除useeffect"}},[e._v("#")]),e._v(" 如何清除useEffect")]),e._v(" "),n("blockquote",[n("p",[e._v("副作用回调函数中返回一个函数，用于副作用的清理工作。")])]),e._v(" "),n("h3",{attrs:{id:"官网案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#官网案例"}},[e._v("#")]),e._v(" 官网案例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("useEffect(() => {\n  ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n  return () => {\n    ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n  };\n});\n")])])]),n("h3",{attrs:{id:"执行过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[e._v("#")]),e._v(" 执行过程：")]),e._v(" "),n("ul",[n("li",[e._v("每次副作用执行，都会返回一个新的clear函数")]),e._v(" "),n("li",[e._v("clear函数会在下一次副作用逻辑之前执行（DOM渲染完成之后）")]),e._v(" "),n("li",[e._v("组件销毁也会执行一次")])]),e._v(" "),n("h3",{attrs:{id:"案例-一下代码的打印顺序是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#案例-一下代码的打印顺序是什么"}},[e._v("#")]),e._v(" 案例，一下代码的打印顺序是什么？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect } from 'react';\n\nexport default function AnimateDemo() {\n  const [counter, setCounter] = useState(0);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setCounter(counter + 1);\n    }, 300);\n    console.log('effect:', timer);\n\n    return () => {\n      console.log('clear:', timer);\n      clearTimeout(timer);\n    }\n  });\n\n  console.log('before render');\n\n  return (\n    <div className=\"container\">\n      <div className=\"el\">{counter}</div>\n    </div>\n  )\n}\n")])])]),n("h3",{attrs:{id:"使用多个useeffect来执行不同的副作用逻辑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用多个useeffect来执行不同的副作用逻辑"}},[e._v("#")]),e._v(" 使用多个useEffect来执行不同的副作用逻辑")]),e._v(" "),n("p",[e._v("React Hooks 允许我们使用多个useEffect来执行不同的副作用逻辑。")]),e._v(" "),n("p",[e._v("React 将按照 effect 声明的顺序依次调用组件中的每一个 effect")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React, { useState, useEffect } from "react";\n\nfunction Person({ userid }) {\n  const [person, setPerson] = useState();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    document.title = `当前是用户${userid}`\n  })\n\n  useEffect(() => {\n    console.log("exec useEffect");\n    setLoading(true);\n    fetch(`https://swapi.co/api/people/${userid}`)\n      .then(res => res.json())\n      .then(data => {\n        setPerson(data);\n        setLoading(false);\n      });\n  }, [userid]);\n\n  return (\n    <div>\n      用户信息：\n      <p>{loading ? "Loading..." : JSON.stringify(person)}</p>\n    </div>\n  );\n}\n\nexport default function Demo03() {\n  const [userid, setuUserid] = useState(1);\n  return (\n    <>\n      <button onClick={() => setuUserid(1)}>用户1</button>\n      <button onClick={() => setuUserid(2)}>用户2</button>\n      <Person userid={userid} />\n    </>\n  );\n}\n\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);