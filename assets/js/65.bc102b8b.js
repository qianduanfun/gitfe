(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{464:function(e,t,n){"use strict";n.r(t);var a=n(48),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"lru-cache"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lru-cache"}},[e._v("#")]),e._v(" lru-cache")]),e._v(" "),n("p",[e._v("一个高速缓存对象，用于删除最近最少使用的项目内容")]),e._v(" "),n("h3",{attrs:{id:"安装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[e._v("#")]),e._v(" 安装")]),e._v(" "),n("p",[e._v("npm install lru-cache --save")]),e._v(" "),n("p",[e._v("地址： https://www.npmjs.com/package/lru-cache")]),e._v(" "),n("h3",{attrs:{id:"使用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[e._v("#")]),e._v(" 使用场景")]),e._v(" "),n("blockquote",[n("p",[e._v("nextjs框架使用服务端渲染数据，一旦用户量增大，频繁调取服务端接口会使服务器压力增大，造成不必要的麻烦，所以需要做页面缓存，减少不必要的数据调取。\n网页登录信息缓存。对于需要获取登录信息的页面，我们需要给定一段时间内的信息缓存，避免频繁获取用户信息。\n避免较短时间内页面频繁刷新造成资源频繁调取的情况。")])]),e._v(" "),n("h3",{attrs:{id:"基础用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基础用法"}},[e._v("#")]),e._v(" 基础用法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var LRU = require("lru-cache")\n  , options = { max: 500  \n              , length: function (n, key) { return n * 2 + key.length }\n              , dispose: function (key, n) { n.close() }\n              , maxAge: 1000 * 60 * 60 }\n  , cache = new LRU(options)\n\ncache.set("key", "value")\ncache.get("key")\n\n')])])]),n("h3",{attrs:{id:"options参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#options参数"}},[e._v("#")]),e._v(" options参数")]),e._v(" "),n("blockquote",[n("p",[e._v("max： 缓存的最大大小。默认值为Infinity。手动设置时必须是为正的数字，非数字或负数会显示TypeError，设置为0时则为默认值Infinity\nmaxAge: 设置缓存的最长时间。当set完一个key-value 后，超过 maxAge 设置的值时，LRU会自动把 key-value 删掉。\nlength: 用于计算存储项目长度的函数。\ndispose: 从缓存中删除项目。\nstale: 默认情况下，如果设置了maxAge，则会将超时的项目从缓存中删除，但如果设置了stale:true, 它将在删除之前返回旧的值。\nnoDisposeOnSet: 默认情况下，如果设置了dispose()方法，则每当set()操作覆盖现有键时，都会调用该方法。如果您设置了这个选项，那么dispose()只会在键脱离缓存时调用，而不会在键被覆盖时调用。\nupdateAgeOnGet: 当使用maxAge使用时间到期时，将其设置为true将使每个条目的有效时间更新为当前时间，从而使其不会过期。(当然，它仍然会因为使用时间的不同而脱离缓存。)")])]),e._v(" "),n("h3",{attrs:{id:"api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" API")]),e._v(" "),n("blockquote",[n("p",[e._v("set(key, value, maxAge)\n设置缓存，maxAge可选，设置则覆盖全局提供的maxAge\nget(key) => value\n获取key下的缓存内容，如果照不到key值，将返回undefined。\npeek(key)\n返回该键下的键值，如果未找到则返回undefined。\ndel(key)\n从缓存中删除该key值\nreset()\n完全清除缓存，丢弃所有值\nhas(key)\n检查该key值是否存在于缓存中。\nforEach(function(value,key,cache), [thisp])\n按照最新的顺序遍历缓存中的所有项。（首先返回最近使用的项）\nrforEach(function(value,key,cache), [thisp])\n与forEach相反的顺序遍历所有项。（首先返回最少使用的项）\nkeys()\n返回缓存中的键的数组。\nvalues()\n返回缓存中的键值的数组。\nlength\n返回缓存中对象的总长度。\nitemCount\n返回当前缓存中的对象总数。\ndump()\n返回准备好进行序列化和使用'destinationCache.load（arr）`的缓存条目数组。\nload(cacheEntriesArray)\n将通过获取的另一个缓存条目数组加载sourceCache.dump()到缓存中。在加载新条目之前，将重置目标缓存。\nprune()\n手动遍历整个缓存，主动清除旧的条目。")])]),e._v(" "),n("p",[e._v("eg:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  let list = []\n  console.log(ssrCache.has("list"))  // true or false\n  console.log(ssrCache.peek("list")) // undefined or []\n  if (ssrCache.has("list")) {  // 如果查询到缓存中有list值，则返回true\n    list = ssrCache.get("list")   // 并使用缓存中的数据\n  }else{   // 未查询到缓存中存在该值\n    list = await store.dispatch.demo.test()  // 则运行调取数据\n    if(list && list.length){\n      ssrCache.set(\'list\', list)  // 存储数据在缓存中list键下\n    }\n  }\n  return { list };\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);