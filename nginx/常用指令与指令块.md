<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [常用指令与指令块](#常用指令与指令块)
  - [指令 directive](#指令-directive)
  - [指令块 directiveBlock](#指令块-directiveblock)
  - [http 模块](#http模块)
  - [upstream 模块](#upstream模块)
  - [server 模块](#server模块)
  - [location 模块](#location模块)

<!-- /code_chunk_output -->

# 常用指令与指令块

- `http`

- `server`

- `upstream`

- `location`

这四个模块是常用的模块，一般我们有这四个指令就可以将网站文件通过端口映射出来。

```nginx
# 指令块
http {
        # 指令
        # mime.type 含有很多的文件后缀名，和文件关系对照表。
        include mime.types;
        upstream feup {
                server 127.0.0.1:3000;
        }
        server {
                listen 80;
                server_name localhost;

                location / {
                    root /var/www/html;
                    index index.html index.htm;
                }
        }
        server {
            listen 3000;
            server_name localhost;

            location / {
                root /var/www/feup;
                index index.html;

                try_files $uri /index.html @router;
            }
        }
        server {
                listen 80;
                server_name feup.kaikeba.com;

                location / {
                        proxy_pass   http://feup;
                        proxy_http_version 1.1;
                        proxy_set_header Upgrade $http_upgrade;
                        proxy_set_header Connection $connection_upgrade;
                }
        }
}
```

上面的配置文件包含了一些最简单并常用的访问配置。分别对应下面三个地址：

```bash
# nginx的默认访问地址，对应/var/www/html目录
http://127.0.0.1

# feup打包后的访问地址，对应/var/www/feup目录，而且做了路由重定向
http://127.0.0.1:3000

# 我们将feup.kaikeba.com映射到了3000端口，接下来做一个本地hosts映射就可以通过这个地址来访问feup了
http://feup.kaikeba.com
```

## 指令 directive

```nginx
include mime.types;
```

指令可以接受多个参数，参数用空格分割。

可以将它看成 js 里的函数一样。

```js
// 伪代码
function directive(feature, ...props) {
  return feature(...props);
}
```

两个指令之间，使用分号作为分隔符。所以也可以像下面这样写

> 通常不建议这样，因为可读性会变得很差。

```nginx
location ~* \.(gif|jpeg|png|jpg)$ {
        expires 3m; proxy_cache my_zone;
}
```

## 指令块 directiveBlock

后面跟大括号的就是指令块，它的作用就是将多条指令组合在一起。

有些指令块可以有名字，有些是没有名字的。而且指令块内也可以包含其他指令块。

至于什么时候有名字，什么时候不带名字，这个是由提供这个指令块的模块来决定的，可以决定这个指令块有多少个参数。

```nginx
http {
        # upstream 把 server指令 放在了 feup 指令块下面。
        upstream feup {
                server 127.0.0.1:3000;
        }
}
```

## http 模块

代表在 http 模块内的所有指令和指令块，都是由 http 模块去解析去执行的。

## upstream 模块

代表着上游服务，比如我们有个 node 服务、tomcat 服务。需要与这些服务交互的时候可以定义一个 upstream。

```nginx
# Syntax:
upstream name { ... }

# 默认情况下，使用加权循环平衡在服务器之间分配请求

# 默认顺序轮询
# [http]
upstream api_server_upstream {
        server 127.0.0.1:3000;
        server 127.0.0.1:3001;
        server 192.168.111.111:80;
}


# 带权重
# [http]
upstream api_server_name {
        # 如果有7个请求，其中5个请求会到这个3000端口中。其余两个会被分配到其他两个，如果有一个服务挂掉了，那么将会向下重新请求，如果所有的都没有得到响应，那么将会返回最后一个服务的请求结果。
        server 127.0.0.1:3000 weight=5;
        server 127.0.0.1:3001 weight=1;
        server 192.168.111.111:80 weight=1;
}

# ip_hash
# 根据用户请求过来的ip，然后映射成hash值，然后分配到一个特定的服务器里面。
# 从而保证同一个用户过来的请求，只会进入到同一台特定的服务中，会话不会出现在其他服务中。
# 
# 一旦使用了ip_hash，当我们需要移除一台服务器的时候，不能直接删除这个配置项，而是需要在这台服务器配置后面加上关键字down，表示不可用；
# 因为如果直接移除配置项，会导致hash算法发生更改，后续所有的请求都会发生混乱；
# 
# [http]
upstream api_server_upstream {
        ip_hash;
        server 127.0.0.1:3000;
        server 127.0.0.1:3001;
        server 192.168.111.111:80;
}

# 设备状态 down/backup
# [http]
upstream api_server_upstream {
        ip_hash;
        server 203.18.225.19:80 down; // 服务器暂时不参与负载
        server 203.18.225.19:81;
        server 203.18.225.20:80 backup; // 当其他过于繁忙时，参与负载
}

# 还有更多用法，可以下去了自己研究研究。
```

## server 模块

用于对应一个域名或者一组域名。

## location 模块

url 表达式，针对不同 url 做出不同的指令动作。

### 语法

```nginx
# Syntax:
# [server]
location [ = | ~ | ^~ | ~* ] uri { ... }
location @name { ... }
```

### 具体

```nginx
# location =  // 精准匹配
# location ^~ // 前缀匹配
# location ~  // 正则匹配
# location ~* // 不区分大小写正则匹配
# location /  // 无修饰符的匹配


# 完全匹配
location = /a {
   [ configuration A ]
}

# 前缀匹配优于正则匹配
location ^~ /images/ {
   [ configuration D ]
}

# 区分大小写正则匹配
location ~ \.(gif|jpg|jpeg)$ {
   [ configuration E ]
}

# 不区分大小写正则匹配
location ~* \.(gif|jpg|jpeg)$ {
   [ configuration E ]
}

# 匹配前缀
location /a {
   [ configuration B ]
}
```

## alias 和 root

```nginx
# [server]
location /image {
        alias /root/html/image/;
}
＃ alias:　当请求/image/a.jpg-->替换成 /root/html/image/a.jpg

# [server]
location /image {
        root /root/html/image;
}
＃ root:　当请求/image/a.jpg-->替换成 /root/html/image/image/a.jpg
```

- alias 匹配路径全替换
- root 匹配路径前追加 root 路径
